---

layout: post
title: 以新的角度看数据结构
category: 技术
tags: Algorithm
keywords: 数据结构

---


## 前言

* TOC
{:toc}

数据结构 + 数据结构 ==> 某方面更优秀的数据结构。数据结构 + 算法 ==> 更优秀的数据结构。

《算法通关之路》学习算法像拓扑排序，若没有任何的解题经验，普通人不可能创造一个算法来解决问题。积累经验是十分关键的，当我们积累经验达到一定程度的时候，就可以从新问题中找到旧问题的影子，进一步联想过去所使用的解法，并加以转换，从而解决新问题了。

## 整体介绍

数据结构分为逻辑结构、存储结构以及对应结构的数据运算，比如，你可以用一个数组表示一个图，也可以用链表存储一个图（或者一个图中包含数组和链表）。

整体脉络：**数据结构 ==> 增删改查、遍历方法  ==> 基于基本方法之上的，找到符合某一个/多个特征的元素 的算法**。

### 逻辑结构

**数据元素间抽象化的相互关系**，与存储无关，⽐如我们可以⽤数组去存储⼆叉树。主要包括：
1. 集合结构中的数据元素之间除了 “同属于一个集合”的关系外，别无其他关系。
1. 线性结构，数据元素之间只存在一对一的关系。⼀般⽽⾔，**有前驱和后继的就是线性数据结构**。
2. 非线性结构，有了线性结构，我们为什么还需要⾮线性结构呢？ **为了⾼效地兼顾静态操作和动态操作**，我们⼀般使⽤树去管理需要⼤量动态操作的
数据。比如平衡⼆叉搜索树的查找和有序数组的⼆分查找本质都是⼀样的，只是数据的存储⽅式不同罢了。那为什么有了有序数组⼆分，还需要⼆叉搜索树呢？原因在于树的结构对于动态数据⽐较友好，⽐如数据是频繁变动 的，⽐如经常添加和删除，那么就可以使⽤⼆叉搜索树。
    3. 树形结构结构中的数据元素之间存在一对多的关系。
    4. 图状结构或网状结构结构中的数据元素之间存在多对多的关系。

每种逻辑结构包含一些基本的运算，包括遍历，增减节点等。

⼆分的本质是将问题规模缩⼩到⼀半，因此⼆分和数据结构没有本质关系，但是不同的数据结构却给⼆分赋予了不同的⾊ 彩。⽐如**跳表就是链表的⼆分**，⼆叉搜索树就是树的⼆分等。

### 存储结构

主要包括：

1. 顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元里，元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。
2. 链接存储：不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针表示元素之间的逻辑关系。其优点是不会出现碎片现象，充分利用所有存储单元；缺点是每个元素因存储指针而占用额外的存储空间，并且只能实现顺序存取。
3. 索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每一项称为**索引项**，索引项的一般形式是：（关键字，地址）。其优点是检索速度快；缺点是增加了附加的索引表，会占用较多的存储空间。另外，在增加和删除数据时要修改索引表，因而会花费较多的时间。
4. 散列存储：根据元素的关键字直接计算出该元素的存储地址，又称为Hash存储。其优点是检索、增加和删除结点的操作都很快；缺点是如果散列函数不好可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。

**存储/物理结构通常绕不开寻址问题，以及增删改查的效率问题。**我们可以观察到集中存储结构的演进：

1. 顺序存储，直接放在一起
2. 链接存储，数据和位置信息放在一起
3. 索引存储，数据和位置信息完全独立，位置信息存在单独的索引表中
4. 直接寻址表，数据和位置信息完全独立，位置信息存在单独的数组中，数据直接作为数组下标。
5. 哈希表，直接寻址表的改进。

## 数组和链表

各种数据结构，不管是队列，栈等线性数据结构还是树，图的等⾮线性数 据结构，**从根本上底层都是数组和链表**。不管你⽤的是数组还是链表，⽤ 的都是计算机内存，物理内存是⼀个个⼤⼩相同的内存单元构成的。数组和链表是使⽤物理内存的两种⽅式。PS：同样是存储结构，数组和链表更底层一些
1. 数组是连续的内存空间，通常每⼀个单位的⼤⼩也是固定的，因此可以按下标随机访问。
2. 链表不⼀定连续，⼀般我们是通过⼀个叫 next 指针来遍历查找。链表其实就是⼀个结构体。数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由⼀系列结点（链表中每⼀个元素称为结点）组成，结点可以在运⾏时动态⽣成。**链表是⼀种递归的数据结构**，因此采⽤递归的思想去考虑往往事半功倍。

数组对查询特别友好，对删除和 添加不友好，为了解决这个问题，就有了链表这种数据结构。链表适合 在数据需要有⼀定顺序，但是⼜需要进⾏频繁增删除的场景。

有没有想过为啥只有⼆叉树，⽽没有⼀叉树。实际上链表就是特殊的树，即⼀叉树。单链表只有⼀个后继指针。因此只有前序和后序，没有中序遍历。值得注意的是，前序遍历很容易改造成迭代，为什么呢？前序遍历容易改成不需要栈的递归，⽽后续遍历需要借助栈来完成。由于后续遍历的主逻辑在函数调⽤栈的弹出过程，⽽前序遍历则不需要。

1. 由于链表不⽀持随机访问，因此**如果想要获取数组中间项和倒数第⼏项等特定元素**就需要⼀些特殊的⼿段，⽽这个⼿段就是**快慢指针**。⽐如要 找链表中间项就搞两个指针，⼀个⼤步⾛（⼀次⾛两步），⼀个⼩步⾛（⼀次⾛⼀步），这样快指针⾛到头，慢指针刚好在中间。 如果要求链 表倒数第 2 个，那就让快指针先⾛⼀步，慢指针再⾛，这样快指针⾛到头，慢指针刚好在倒数第⼆个。
2. 单链表⽆法在 `O(1)` 的时间拿到前驱节点，这也是为什么我们遍历的时候⽼是维护⼀个前驱节点的原因。但是本质原因其实是**链表的增删操作都依赖前驱节点**，这是链表的基本操作，是链表的特性天⽣决定的。

## 队列

教科书上一说队列，就是四个字“先进先出”,这四个字是无法表述队列的巨大作用的.

### 合并请求的一种实现

假设一个方法或类负责管理一个资源,在多线程环境下,这个类便需要"线程安全"

1. 将这个类改造成线程安全的类
2. 调整这个类的调用方式.利用生产者消费者模式,所有想要使用这个资源的的线程(生产者)先提交请求到一个队列,由一个专门的线程(消费者)负责接收并处理请求.

### 轮询的一种实现

假设我们有一个集合，对集合中的元素实现轮询效果。

1. 我们可以标记一个index，记住上一次使用的元素，进而实现轮询。
2. 用环形队列存储集合，即天然具备轮询效果。

这两种方式，在多线程环境下，还需注意线程安全问题。

## 树

DOM 树是⼀种树结构， ⽽ HTML 作为⼀种 DSL 去描述这种树结构的具体表现形式。如果你接触 过 AST，那么 AST 也是⼀种树，XML 也是树结构。

树其实是⼀种特殊的图 ，是⼀种⽆环连通图，是⼀种极⼤⽆环图，也是⼀种极⼩连通图。

树的遍历分为两种，分别是深度优先遍历和⼴度优先遍历。
1. DFS 沿着树的深度遍历树的节点，尽可能深的搜索树的分⽀。 当节点 v 的所在边都⼰被探寻过，搜索将回溯到发现节点 v 的那条边的起 始节点。这⼀过程⼀直进⾏到已发现从源节点可达的所有节点为⽌。如果 还存在未被发现的节点，则选择其中⼀个作为源节点并重复以上过程，整 个进程反复进⾏直到所有节点都被访问为⽌，属于**盲⽬搜索**。
    1. **树的不同深度优先遍历又分为前中后序**。前中后序实际上是指的**当前节点相对⼦节点的处理顺序**。遍历得从根节点开始访问，然后根据⼦节点指针访问⼦节点，但是 ⼦节点有多个（⼆叉树最多两个）⽅向，所以⼜有了先访问哪个的问题，这造成了不同的遍历⽅式。如果先处理当前 节点再处理⼦节点，那么就是前序。如果先处理左节点，再处理当前节 点，最后处理右节点，就是中序遍历。后序遍历⾃然是最后处理当前节点了。中序多⽤于⼆叉搜索树，因为⼆叉搜索树的中序遍历是严格 递增的数组。
    2. 从另⼀个⻆度看，树是⼀种递归的数据结构。因此树的遍历算法使⽤递归去完 成⾮常简单，幸运的是**树的算法基本上都要依赖于树的遍历**。但是递归在计算机中的性能⼀直都有问题，如果你使⽤迭代式⽅ 式去遍历的话，可以借助栈来进⾏，可以极⼤减少代码量。PS：树，递归，栈
2.  BFS细分为带层的和不带层的。
    1. 层次遍历和 BFS 是完全不⼀样的东⻄，层次遍历就是⼀层层遍历树，按照树的层次顺序进⾏访问，层次遍历是⼀种不需要提前终⽌的 BFS 的副产物。**BFS 的核⼼在于求最短问题时候可以提前终⽌**，这才是它的核⼼价值， 比如求最短距离，这个提前终⽌不同于DFS 的剪枝的提前终⽌，⽽是找到最近⽬标的提前终⽌。⽐如我要找距 离最近的⽬标节点，BFS 找到⽬标节点就可以直接返回，⽽ DFS 要穷举 所有可能才能找到最近的。
    2. BFS 采⽤横向搜索的⽅式， 在数据结构上通常采⽤队列结构。

由于链表只有⼀个 next 指针， 因此只有两种遍历。⽽⼆叉树有两个指针，因此常⻅的遍历有三个，除了 前后序，还有⼀个中序。如果是前序遍历，那么你可以想象上⾯的节点都处理好了，怎么处理的不 ⽤管。相应地如果是后序遍历，那么你可以想象下⾯的树都处理好了，怎 么处理的不⽤管。前后序对链表来说⽐较直观。对于树来说，其实更形象地说应该是⾃顶向 下或者⾃底向上。

### DFS

DFS算法流程
1. ⾸先将根节点放⼊stack中。 
2. 从stack中取出第⼀个节点，并检验它是否为⽬标。如果找到所有的 节点，则结束搜寻并回传结果。否则将它某⼀个尚未检验过的直接⼦ 节点加⼊stack中。 
3. 重复步骤 2。 
4. 如果不存在未检测过的直接⼦节点。将上⼀级节点加⼊stack中。 重 复步骤 2。 
5. 重复步骤 4。 
6. 若stack为空，表示整张图都检查过了——亦即图中没有欲搜寻的⽬标。结束搜寻并回传“找不到⽬标”。 

这⾥的 stack 可以理解为⾃⼰实现的栈，也可以理解为“调⽤栈”。如果是“调⽤栈”的时候就是递归，如果是⾃⼰实现的栈的话就是迭代。

⼀个典型的通⽤的 DFS 模板可能是这样的：

```
const visited = {}
function dfs(i) {
    if (满⾜特定条件）{
        // 返回结果 or 退出搜索空间
    }
    visited[i] = true       // 将当前状态标为已搜索
    for (根据i能到达的下个状态j) {
        if (!visited[j]) {  // 如果状态j没有被搜索过
            dfs(j)
        }
    }
}
```
上⾯的 visited 是为了防⽌由于环的存在造成的死循环的。 ⽽我们知道树 是不存在环的，因此树的题⽬⼤多数不需要 visited，因此⼀个树的 DFS 更多是
```
function dfs(root) {
    if (满⾜特定条件）{
        // 返回结果 or 退出搜索空间
    }
    for (const child of root.children) {
        dfs(child)
    }
}
```
⽽⼏乎所有的题⽬⼏乎都是⼆叉树，因此下⾯这个模板更常⻅。
```
function dfs(root) {
    if (满⾜特定条件）{
        // 返回结果 or 退出搜索空间
    }
    dfs(root.left)
    dfs(root.right)
}
```
PS：这段代码有点抛开数据结构 描述算法的味道。数据结构是为算法服务的，算法通常也要建立在某一种或几种数据结构之上。因为没有数据结构直接满足业务问题的需求，所以**你可以先假设存在这个数据结构，看看算法怎么做，慢慢剥洋葱**，去掉外围、表象，先定义需求再想实现，慢慢跟已有的经验靠拢。 

```
// 前序遍历
function dfs(root) {
    if (满⾜特定条件）{
        // 返回结果 or 退出搜索空间
    }
    // 主要逻辑
    dfs(root.left)
    dfs(root.right)
}
// 后序遍历
function dfs(root) {
    if (满⾜特定条件）{
        // 返回结果 or 退出搜索空间
    }
    dfs(root.left)
    dfs(root.right)
    // 主要逻辑
}
```
树是一个递归结构，因此大部分算法可以先用递归实现，然后看看要求再转为迭代实现。

### BFS

1. ⾸先将根节点放⼊队列中。 
2. 从队列中取出第⼀个节点，并检验它是否为⽬标。 如果找到⽬标，则结束搜索并回传结果。 否则将它所有尚未检验过的直接⼦节点加⼊队列中。 
3. 若队列为空，表示整张图都检查过了——亦即图中没有欲搜索的⽬
标。结束搜索并回传“找不到⽬标”。 
4. 重复步骤 2。

```
const visited = {}
function bfs() {
    let q = new Queue()
    q.push(初始状态)
    while(q.length) {   // 队列不空，⽣命不⽌
        let i = q.pop()
        if (visited[i]) continue
        if (i 是我们要找的⽬标) return 结果
        for (i的可抵达状态j) {
            if (j 合法) {
                q.push(j)
            }
        }
    }
    return 没找到 
}
```

## 图

深度优先和广度优先遍历，{初始状态，目标状态，规则集合}在寻找最佳策略上的应用，**不管你是什么算法，肯定都要遍历的**，不管是哪⼀种遍历， 如果图有环，就⼀定要记录节点的访问情况，防⽌死循环。DFS 和 BFS 只是⼀种算法思想，不是⼀种具体的算法，因此其有着很强的适应性，⽽不是局限于特点的数据结构的，图 可以⽤，前⾯讲的树也可以⽤（树的前序、中序、后序就是以根节点为起点的 DFS 和 BFS 遍历）。实际上， **只要是⾮线性的数据结构都可以⽤**。


## 堆

堆其实就是⼀种数据结构，数据结构是为了算法服务的，**那堆这种数据结构是为哪种算法服务的？它的适⽤场景是什么？ 这是每⼀个学习堆的⼈ 第⼀个需要解决的问题**。给⼤家⼀个**学习建议 - 先不要纠结堆怎么实现的，咱先了解堆解决了什么问题。当你了解了使⽤背景和解决的问题之后，然后当⼀个调包侠，直接⽤现成的堆的 api 解决问题**。等你理解得差不多了，再去看堆的原理和实现。

假如你是⼀个排队挂号系统的技术负责⼈。该系统需要给每⼀个前来排队 的⼈发放⼀个排队码（⼊队），并根据先来后到的原则进⾏叫号（出 队）。 除此之外，我们还可以区分了⼏种客户类型， 分别是普通客户， VIP 客 户 和 ⾄尊 VIP 客户。 
1. 如果不同的客户使⽤不同的窗⼝的话，我该如何设计实现我的系统？ （⼤家获得的服务不⼀样，⽐如 VIP 客户是专家级医⽣，普通客户是 普通医⽣） 
2. 如果不同的客户都使⽤⼀个窗⼝的话，我该如何设计实现我的系统？ （⼤家获得的服务都⼀样，但是优先级不⼀样。⽐如其他条件相同情 况下(⽐如他们都是同时来挂号的)，VIP 客户 优先级⾼于普通客户）

堆的两个核⼼ API 是 push 和 pop。
1. push ： 推⼊⼀个数据，内部怎么组织我不管。对应我上⾯场景⾥ ⾯的排队和插队。
2. pop ： 弹出⼀个数据，该数据⼀定是最⼩的，内部怎么实现我不 管。对应我上⾯场景⾥⾯的叫号。

简单总结下就是，**堆就是动态帮你求极值的**。当你需要动态求最⼤或最⼩ 值就就⽤它。

堆两种常⻅的实现
1. ⼀种是基于链 表的实现- 跳表。不借助额外空间的情况下，在链表中查找⼀个值，需要按照顺 序⼀个个查找，时间复杂度为 O(N)。我们从链表中每两个元素抽出来，加⼀级索引，⼀级索引指 向了原始链表。如果元素继续增⼤， 继续增加索引的层 数，建⽴⼆级，三级。。。索引，使得链表能够实现⼆分查找，从⽽获得 更好的效率。但是相应地，我们需要付出额外空间的代价。
2. ⼀种是基于数组的实现 - ⼆叉堆。⼆叉堆就是⼀颗特殊的完全⼆叉树。它的特殊性只体现在⼀ 点，那就是⽗节点的权值不⼤于⼉⼦的权值（⼩顶堆）。那么很⾃然能推导出树 的根节点就是最⼩值。这就起到了堆的取极值的作⽤了。那动态性呢？⼆叉堆是怎么做到的呢？出堆：弹出根节点，使用最右侧节点（数组最后一个元素，方便访问）作为根节点，下沉以便符合堆的性质。 入堆：新节点作为最后一个节点，上浮以便符合堆的性质。
3. 基于红⿊树 的实现。

## 递归和动态规划

1. ⼆分法的中⼼ - 折半。即⼆分法⽆论如何我们都可以舍弃⼀半解，也就是⽆论如何都可 以将解空间砍半。难点就是：什么条件 和 舍弃哪部分。 这是⼆分法核⼼要解决的问题。
2. 递归并不是算法，它是和迭代对应的⼀种编程⽅法。只不过，我们通常借 助递归去分解问题⽽已。递归中如果存在重复计算（我们称重叠⼦问题，下⽂会讲到），那就是使 ⽤记忆化递归（或动态规划）解题的强有⼒信号之⼀。可以看出动态规划 的核⼼就是使⽤记忆化的⼿段消除重复⼦问题的计算，如果这种重复⼦问 题的规模是指数或者更⾼规模，那么记忆化递归（或动态规划）带来的收 益会⾮常⼤。为了消除这种重复计算，我们可使⽤查表的⽅式。即⼀边递归⼀边使⽤ “记录表”（⽐如哈希表或者数组）记录我们已经计算过的情况，当下次再 次碰到的时候，如果之前已经计算了，那么直接返回即可，这样就避免了 重复计算。
3. 如果你刚开始接触递归，⼀个简 单练习递归的⽅式是将你写的迭代全部改成递归形式。⽐如你写了⼀个程 序，功能是“将⼀个字符串逆序输出”，那么使⽤迭代将其写出来会⾮常容 易，那么你是否可以使⽤递归写出来呢？通过这样的练习，可以让你逐步 适应使⽤递归来写程序。
4. 动态规划最重要的两个概念：最优⼦结构和⽆后效性。
    1. ⽆后效性决定了是否可使⽤动态规划来解决。即⼦问题的解⼀旦确定，就不再改变，不受在这之后、包含它的更⼤的问 题的求解决策影响。背包问题中选择是否拿第三件物品，不应该影 响是否拿前⾯的物品。⽐如题⽬规定了拿了第三件物品之后，第⼆件
物品的价值就会变低或变⾼）。这种情况就不满⾜⽆后向性。
    2. 最优⼦结构决定了具体如何解决。
5. **动态规划的中⼼点是什么？那就是定义状态**。定义好了状态，就可以画出递归 树，聚焦最优⼦结构写转移⽅程就好了，因此我才说状态定义是动态规划 的核⼼，动态规划问题的状态确实不容易看出。⽐如⼀个字符串的状态，通常是 dp[i]表示字符串 s 以 i 结尾的 ....。 ⽐如两个字符串的状态，通常是 dp[i][j] 表 示字符串 s1 以 i 结尾，s2 以 j 结尾的 ....。 当你定义好了状态，剩下就三件事了：
    1. 临界条件； 比如⼀个⼈爬楼梯，每次只能爬 1 个或 2 个台阶，假设有 n 个台阶，那么这 个⼈有多少种不同的爬楼梯⽅法？如果我们⽤ f(n) 表示爬 n 级台阶有多少种⽅ 法的话，f(1) 与 f(2) 就是【边界】，`f(n) = f(n-1) + f(n-2)` 就是【状态转移公式】。
    2. 状态转移⽅程；动态规划中当前阶段的状态往往是上⼀阶段状态和上⼀阶段决策的结果。也就是说，如果给定了第 k 阶段的状态 s[k] 以及决策 choice(s[k])，则第k+1 阶段的状态 s[k+1] 也就完全确定，⽤公式表示就是：`s[k] +choice(s[k]) -> s[k+1]`， 这就是状态转移⽅程。需要注意的是 choice 可能 有多个，因此每个阶段的状态 s[k+1]也会有多个。
        ![](/public/upload/algorithm/dynamic_programming_condition.png)
    3. 枚举状态。一些场景下，遍历顺序取决于状态转移⽅程。⽐如下面代码 我们就需要从左到右遍历，原因很简单，因为 dp[i] 依赖于 dp[i - 1]， 因此计算 dp[i] 的时候， dp[i - 1] 需要已经计算好了。如果是⼀维状态，那么我们使⽤⼀层循环可以搞定。如果是两维状态，那么我们使⽤两层循环可以搞定。
        ```
        for i in range(1, n + 1):
            dp[i] = dp[i - 1] + 1
        ```

爬楼梯问题的递归写法
```
function dp(n) {
    if (n === 1) return 1;
    if (n === 2) return 2;
    return dp(n - 1) + dp(n - 2);
}
```
爬楼梯问题的动态规划写法，查表，即db table(dynamic_programming)，⼀般我们写的 dp table，数组的索引通常对应记忆化递归的函数参数， 值对应递归函数的返回值。
```
function climbStairs(n) {
    if (n == 1) return 1;
    const dp = new Array(n);
    dp[0] = 1;
    dp[1] = 2;
    for (let i = 2; i < n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[dp.length - 1];
}
```
他们的区别只不过是递归⽤调⽤栈枚举状态， ⽽动态规划使⽤迭 代枚举状态。

## 碎碎念

### 设计数据结构的过程是一种“映射”

[Data Structure](https://www.encyclopedia.com/computing/dictionaries-thesauruses-pictures-and-press-releases/data-structure)Computer solution of a real-world problem involves designing some ideal data structures, and then mapping these onto available data structures (e.g. arrays, records, lists, queues, and trees) for the implementation. 先假设一种理想结构 然后再考虑着 组合基本结构去实现。


我们说面向的对象的四个基本特性：抽象、封装、继承、多态。在四个基本特性之上呢，一群类的组合，有了各种设计模式。

数组 + 哈希函数 就成了一个散列表。 也就是 基本特性的组合，是否也有设计模式一说呢？ 对于跳表来说，与其说数据结构本来就是那样子，还不如说为了在链表上提高查询速度而衍生的数据结构。亦或者说B+树，我们也可以说先有底层那一条叶子链，再有的上层索引结构。

![](/public/upload/algorithm/data_structure_vs_object.png)



### 为什么查询和排序是数据结构的基本操作

以缓存为例，一个缓存（cache）系统主要包含下面这几个操作：

1. 往缓存中添加一个数据
2. 从缓存中删除一个数据
3. 在缓存中查找一个数据

这三个操作都涉及到查找操作，换句话说，对数据的操作无外乎crud，而cud都离不开查询。进而很明显，基于有序结构的查询速度是最快的，也就引出了排序算法的重要性。


### 查询的不同意涵

数据结构，model the application data，it is generally a requirement for any application to insert, edit and query a data store. Data structures offer different ways to store data items, while the algorithms provide techniques for managing this data. 不管什么样的数据结构，都跑不掉insert、edit、和query。尤其是query ，对于不同的数据结构，意涵很丰富

1. 查询的入参不同，可能是index、数据的某个属性、范围、数据的某个特征（比如第k大的数）
2. 查询返回的结果不同，可能是数据本身、数据集合、也可能是多个数据的组合（比如图的最优路径）

### 多重查询

1. 数组 + hash 构成了散列表，根据index 查询和 key 查询 都是O(1)
2. 假设 既想根据学号 又想根据成绩 查询学生，则可以先按学号递增组织学生数据，再按照分数构造一个散列表（该思想对应到数据库上，就是针对主键另外建了一个非聚簇索引）。

为什么散列表和链表经常会一起使用？

1. 链表只能基于一个维度来构建有序数据，也只能基于这个维度来查询数据。基于链表构建一个散列表 则相当于 构建了一个“非聚簇索引”，增加了查询维度。
2. 散列表中数据是经过散列函数打乱之后无规律存储的，在散列表上加链表（使用指针将散列表的n 个拉链 串起来），则可以支持散列表按照插入或访问顺序遍历数据，比如java中的LinkedHashMap。


### 数据结构与业务设计

一般的业务系统要建立数据库表，数据库表要建立索引。笔者有一个经验，不要一开始建立索引。而是业务代码完毕后，观察常查询的属性，然后对这些数据建立索引。如果你愿意，索引 + 数据库表，就是一种数据结构，数据结构的构建（比如建立索引） 要反应业务的“意志”。

[Definition of a Data Structure & Algorithms](https://smallbusiness.chron.com/definition-data-structure-algorithms-27214.html)Computing applications use many different types of data. Some applications model data within database systems, in which case the database system handles the details of choosing data structures, as well as the algorithms to manage them. However, in many cases, applications model their own data. When programmers decide what type of data structure to use for a particular set of data in an application, they need to take into account the specific data items to be stored, the relationships between data items and how the data will be accessed from within the application logic. [ddd(一)——领域驱动理念入门](http://qiankunli.github.io/2017/12/25/ddd.html) 也提到，一般业务以数据库ER设计为驱动，数据库设计代表了对业务的认识深度，也是业务的精华所在。 由此看， 数据库完成了一个项目本身应有的数据结构与算法的活儿，我们不用直接进行数据结构设计（这由数据库封装），而是通过ER表设计来间接影响数据库进行实际的数据结构设计。

Algorithms for managing data structures sometimes involve recursion. With recursion, an algorithm calls itself, which means it repeats its own processes as part of a looping structure, with each step simplifying the problem at hand. Recursive algorithms can allow programmers to implement efficient sorting and searching techniques within their applications. However, writing recursive algorithms can be difficult for beginners, as it does require a significant amount of practice. 这段有一个很有意义的观点，Recursive algorithms 一般要对应 looping structure，是不是可以笼统的说：递归的算法一般对应着可以递归的数据结构。 

## 数据结构的"基本类型化"

较早出现的编程语言,比如c语言,基本类型只包括:int,char,long等,string,map等则需要引用库.而对于新兴语言,比如go和python等,则在语言层面支持string,map等复杂结构.这一趋势,甚至扩展到了一些内存数据库.



