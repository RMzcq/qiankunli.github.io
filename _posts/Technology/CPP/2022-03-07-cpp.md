---

layout: post
title: c++学习
category: 技术
tags: CPP
keywords: c++

---

## 简介（未完成）

* TOC
{:toc}


RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。

当我们在一个函数内部使用局部变量，当退出了这个局部变量的作用域时，这个变量也就别销毁了；当这个变量是类对象时，这个时候，就会自动调用这个类的析构函数。由于系统的资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。

## 标准库

标准库三大要件：容器、算法、迭代器

```c++
auto n = std::count_if(      // count_if算法计算元素的数量
    begin(v), end(v),       // begin()、end()获取容器的范围
    [](auto x) {            // 定义一个lambda表达式
        return x > 2;       // 判断条件
    }
);                          // 大函数里面套了三个小函数
```

因为标准算法的名字实在是太普通、太常见了，所以建议你一定要显式写出“std::”名字空间限定，这样看起来更加醒目，也避免了无意的名字冲突。


## 多线程
在 C++ 语言里，线程就是一个能够独立运行的函数。

```c++
auto f = []()                // 定义一个lambda表达式
{
    cout << "tid=" <<
        this_thread::get_id() << endl;
};

thread t(f);                // 启动一个线程，运行函数f
```

多线程说它不难，是因为线程本身的概念是很简单的，只要规划好要做的工作，不与外部有过多的竞争读写，很容易就能避开“坑”，充分利用多线程，“跑满”CPU。说它难，则是因为现实的业务往往非常复杂，很难做到完美的解耦。一旦线程之间有共享数据的需求，麻烦就接踵而至，因为要考虑各种情况、用各种手段去同步数据。

thread_local
```c++
thread_local int n = 0;        // 线程局部存储变量
auto f = [&](int x)           // 在线程里运行的lambda表达式，捕获引用
{   
    n += x;                   // 使用线程局部变量，互不影响
    cout << n;                // 输出，验证结果
};  
thread t1(f, 10);           // 启动两个线程，运行函数f
thread t2(f, 20);
```

原子变量

```c++
using atomic_bool = std::atomic<bool>;    // 原子化的bool
using atomic_int  = std::atomic<int>;      // 原子化的int
using atomic_long = std::atomic<long>;    // 原子化的long

atomic_int  x {0};          // 初始化，不能用=
atomic_long y {1000L};      // 初始化，只能用圆括号或者花括号
assert(++x == 1);           // 自增运算
y += 200;                   // 加法运算
assert(y < 2000);           // 比较运算 
```
异步
```c++
auto task = [](auto x)                  // 在线程里运行的lambda表达式
{
    this_thread::sleep_for( x * 1ms);  // 线程睡眠
    cout << "sleep for " << x << endl;
    return x;
};
auto f = std::async(task, 10);         // 启动一个异步任务
f.wait();                              // 等待任务完成
assert(f.valid());                    // 确实已经完成了任务
cout << f.get() << endl;              // 获取任务的执行结果
```
async() 会返回一个 future 变量，可以认为是代表了执行结果的“期货”，如果任务有返回值，就可以用成员函数 get() 获取。不过要特别注意，get() 只能调一次，再次获取结果会发生错误，抛出异常 std::future_error。另外，这里还有一个很隐蔽的“坑”，如果你不显式获取 async() 的返回值（即 future 对象），它就会同步阻塞直至任务完成（由于临时对象的析构函数），于是“async”就变成了“sync”。所以，即使我们不关心返回值，也总要用 auto 来配合 async()，避免同步阻塞，就像下面的示例代码那样：
```c++
std::async(task, ...);            // 没有显式获取future，被同步阻塞
auto f = std::async(task, ...);   // 只有上一个任务完成后才能被执行
```