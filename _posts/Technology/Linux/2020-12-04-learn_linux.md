---

layout: post
title: 学习Linux
category: 技术
tags: Linux
keywords: debug

---

## 简介

* TOC
{:toc}

[一文带你真正认识 Linux 系统结构](https://mp.weixin.qq.com/s/D9kahIenezVJDCj8pTyi4Q)

## 艺术性

1. 指令是稳定的，但指令序列是变化的，只有这样计算机才能够实现 “解决一切可以用 ‘计算’ 来解决的问题” 这个目标。计算是稳定的，但数据交换是多变的，只有这样才能够让计算机不必修改基础架构却可以适应不断发展变化的交互技术革命。
2. 通过引入缺页中断，CPU 将自身与多变的外置存储设备，以及多变的文件系统格式进行了解耦。
3. 中断机制，我们可以简单把它理解为 CPU 引入的回调函数。通过中断，CPU 把对计算机外设的演进能力交给了操作系统。

## 中断

单机操作系统的系统调用需要「陷入」内核，所谓的陷入（trap）也叫做中断（interrupt），无论内核是什么类型，单机操作系统都需要在启动时将系统调用注册到内存中的一个区域里，这个区域叫做中断向量（Interrupt Vector）或中断描述符表（IDT，Interrupt Descriptor Table）。当然，现代操作系统的中断处理非常复杂，系统调用也很多，因此除了IDT之外，还需要一张系统调用表（SCV，System Call Vector），系统调用通过一个统一的中断入口（如 INT 80）调用某个中断处理程序，由这个中断处理程序通过 SCV 把系统调用分发给内核中不同的函数代码。因此 SCV 在操作系统中的位置和在星际争霸中的位置同样重要。对微内核架构来说，除了 SCV 中的系统调用之外，用户态服务提供什么样的系统能力，同样需要注册到某个区域。

## 微内核 vs 宏内核

[什么是微内核架构设计？](https://mp.weixin.qq.com/s/V8jwHxvd7WzoiPUe6QENGg)微内核是这样一种内核：它只完成内核不得不完成的功能，包括时钟中断、进程创建与销毁、进程调度、进程间通信，而其他的诸如文件系统、内存管理、设备驱动等都被作为系统进程放到了用户态空间，一般是单独的用户态 daemon 进程。用户态应用程序通过 IPC 访问这些服务，从而访问操作系统的全部功能，如此一来，需要陷入内核的系统调用数量将大大减少，系统的模块化更加清晰。同时系统更加健壮，只有内核中的少量系统调用才有权限访问硬件的全部能力。说白了，微内核是相对于宏内核而言的，像Linux就是典型的宏内核，它除了时钟中断、进程创建与销毁、进程调度、进程间通信外，其他的文件系统、内存管理、输入输出、设备驱动管理都需要内核完成。

[Kubernetes: 微内核的分布式操作系统](https://mp.weixin.qq.com/s/xesu3S0Z4KSh1EsA3eDUqw)微内核的概念虽然美好，但现实非常残酷：在 Linux 中，系统调用（比如 open）只要陷入内核一次，如果在一个微内核操作系统中，用户调用 open 就需要先拼装一条 IPC 请求消息，发送给对应的文件系统服务进程，随后从文件系统服务进程获取IPC响应消息并解包，拿到调用结果，这样一来，消息带来的数据拷贝和进程上下文切换都会带来很多开销。消息需要拷贝是因为用户态进程间不能相互访问内存地址，而内核的代码可以访问任何用户态进程的任何内存地址。在电脑性能不佳的情况下，因为乔布斯无法说服销售团队换一根更强的内存条，因此初代 Mac 的性能较差，未能获得应得的蓝海成功。

![](/public/upload/linux/kernel_design.png)

但是这里还有一个问题，那就是进程间通讯。你可能会问，这个有什么好疑问的，就是两个进程之间相互发消息呗。但是这里有一个最大的疑问，那就是进程间通讯是否有第三者介入？如下图：

![](/public/upload/linux/communication_between_process.png)

当然在操作系统的内核设计中，一定是通过内核进行转发的，就是我们理解的总线架构，内核负责协调各个进程间的通讯。这个大家也能理解，如果进程A直接发给另外一个进程B，必然要了解对应的内存地址，微内核中的服务是可以被随时替换的，如果服务不可用或者被替换，这个时候要通知和其通讯的其他进程，是不是太复杂？刚才已经提到，只有send和receive接口，没有其他通知下线、服务不可用的接口。在微内核的设计中，一定是通过总线结构，进程向Kernel发送消息，然后kernel再发送给对应的进程，这样的一个总线设计。实际上很多应用内部在做Plug-in组件解耦时，都会使用EventBus的结构，其实就是总线的设计机制。