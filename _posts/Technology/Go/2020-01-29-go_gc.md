---

layout: post
title: go gc
category: 技术
tags: Go
keywords: Go gc

---

## 前言

* TOC
{:toc}

[万字长文深入浅出 Golang Runtime](https://zhuanlan.zhihu.com/p/95056679)

现代计算机语言大多数都带有自动内存管理功能，也就是垃圾收集（GC）。程序可以使用堆中的内存，但我们没必要手工去释放。垃圾收集器可以知道哪些内存是垃圾，然后归还给操作系统。垃圾收集包括标记-清除、停止-拷贝两大类算法，停止-拷贝算法被认为是最快的垃圾收集算法，但停止-拷贝算法有缺陷STW（Stop-The-World）。 **在自动内存管理领域的一个研究的重点，就是如何缩短这种停顿时间**。以 Go 语言为例，它的停顿时间从早期的几十毫秒，已经降低到了几毫秒。甚至有一些激进的算法，力图实现不用停顿。增量收集和并发收集算法，就是在这方面的有益探索。

增量收集可以每次只回收部分对象，没必要一次把活干完，从而减少停顿。并发收集就是在不影响程序执行的情况下，并发地执行垃圾收集工作。为了讨论增量和并发收集算法，我们定义两个角色：一个是收集器（Collector），负责垃圾收集；一个是变异器/应用程序（Mutator），它会造成可达对象的改变。

[Visualizing memory management in Golang](https://deepu.tech/memory-management-in-golang/#:~:text=collection%20comes%20in.-,Go%20Memory%20management,is%20well%20optimized%20and%20efficient.) 有动图建议细读

## 三色标记法

[V8 增量 GC 之三色标记](https://malcolmyu.github.io/2019/07/07/Tri-Color-Marking/)三色标记主要是为了解决增量标记中传统双色标记过程无法分片的问题，有了三色标记，传统的双色标记便可以暂停重启，因此就可以划分成小段，变成跟 mutator 并发的方式来运行；写屏障则是用来解决并发中 mutator 变化，导致有用内存被清理的问题。

### 为什么双色标记就不行

采取 STW 这样凶残的策略，主要还是防止 mutator 在 GC 的时候捣乱——这跟你用扫地机器人的时候先把狗（Mutator/Application）先锁起来，等房子全部打扫完再把狗放开 的道理是一样的（Stop The Dog）。

[新一代垃圾回收器ZGC的探索与实践](https://mp.weixin.qq.com/s/ag5u2EPObx7bZr7hkcrOTg) **与jvm ZGC 非常类似**。自己的理解：
1. java对象头信息是跟对象自身定义的数据结构无关的，**这些信息所记录的状态是用于JVM对对象的管理的**（比如并发访问和gc）。
2. gc root 是一些固定特点的对象，一直存在。gc过程可以看做给 gc root加子节点的过程，最后得出一棵树（可达对象在“物理平面”是犬牙交错的），节点有两种状态：在不在树上（可达不可达，对象头mark word 有专门字段），在树上的节点不会被回收。事实上树并不存在（否则对象头 就得有字段表示子节点了），只是gc 线程遍历轨迹的一种表示。
3. 抛开gc 线程和应用线程，线程A和线程B竞争访问同一个对象，可以线程安全的一个底层机制就是，对象头 里有一个mark word 标记了对象是线程A的“人”，当线程B 从对象 mark word 中发现 对象“名花有主”了，就会放弃操作 对象，等待。
4. gc 线程和 应用线程 也是如此，之前 gc 和 应用线程没有 沟通机制，所以gc 干活儿的时候，应用线程就得 “歇着”。涂色 本质上 是提供了一种沟通渠道，在对象上做标记（就像对象mark word上的 线程标识符一样），gc 线程便不会回收这些对象了。



[Go 垃圾回收（三）——三色标记法是什么鬼？](https://zhuanlan.zhihu.com/p/105495961/)

因为增量回收是并发的（concurrent），这就意味着 GC 可能被随时暂停、重启，因此暂停时需要保存当时的扫描结果，等下一波 GC 来之后还能继续启动。而双色标记实际上仅仅是对扫描结果的描述：非黑即白，但忽略了对扫描进行状态的描述：这个点的子节点扫完了没有？假如我上次停在这样一个图上，重新启动的时候我就不仅要问：到底 A、B 点要不要扫子节点？

![](/public/upload/go/black_white.jpg)

相比传统的标记清扫算法，**三色标记最大的好处是可以异步执行**，从而可以以中断时间极少的代价或者完全没有中断来进行整个 GC。全量标记 必须扫描所有的 GC 根，才能确认一个对象是垃圾。**增量标记**是用三种颜色来表示不同的内存对象的处理阶段：
1. 白色，表示算法还没有访问的对象。
2. 灰色，表示这个节点已经被访问过，但子节点还没有被访问过。
3. 黑色，表示这个节点已经被访问过，子节点也已经被访问过了。

![](/public/upload/go/three_color_marking.gif)

[Go: How Does the Garbage Collector Mark the Memory?](https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976)GC 从栈开始，递归地顺着指针找指针指向的对象，遍历内存。每个指针被加入到一个 work pool(`type workbuf struct`) 中的队列。后台运行的标记 worker 从这个 work pool 中拿到前面出列的 指针，扫描这个对象然后把在这个对象里找到的指针加入到队列。归功于每一个 span 中的名为 gcmarkBits 的 bitmap 属性，三色被原生地实现了，bitmap 对 scan 中相应的 bit 设为 1 来追踪 对象。灰色和黑色在 gcmarkBits 中皆为 1，A grey object is one that is marked and on a work queue. A black object is marked and not on a work queue.

```go
type mspan struct {
    next *mspan             // next span in list, or nil if none
    prev *mspan             // previous span in list, or nil if none
    startAddr uintptr       // address of first byte of span aka s.base()
    npages    uintptr       // number of pages in span
    spanclass   spanClass     // size class and noscan (uint8)
    ...
    allocBits  *gcBits
	gcmarkBits *gcBits        // 实现 span 的颜色标记
}
```

PS：感觉三色标记比较重要的 是这个work pool， 每次gc 协程恢复执行后，可以从work pool 拿到对象继续工作。还有就是，因为go的 object 不像java object 一样有对象头，go gc 的回收是以 span 为基本单位的吗？


### 调皮的 mutator

什么是失败的垃圾回收？无非就是两点：
1. 把有用的东西扔了；
2. 把没用的东西留着；这个可以下一轮再说

[Go 垃圾回收（四）——一次完整的回收](https://zhuanlan.zhihu.com/p/105571503)

三色**标记**法是一种可以并发执行的算法。Collector可以做了一段标记工作后，就让mutator再运行一段。如果在mutator运行期间，一个黑色对象被修改了，比如往一个黑色对象 a 里新存储了一个指针 b，那么把 a 涂成灰色，或者把 b 涂成灰色，就可以了。增量标记的过程中，需要编译器做配合往生成的目标代码中插入读屏障（Read Barrier）和写屏障（Write Barrier）的代码。也就是在程序读写对象的时候，要执行一些逻辑，保证三色的正确性。比如Write Barrier 主要做这样一件事情，**修改原先的写逻辑，当白色节点交由黑色节点引用时， 立刻对被引用节点进行着色，并且着色为”灰色“，并加入到work pool**。因此打开了 Write Barrier 可以保证了三色标记法在并发下安全正确地运行。 另一种表述：since the garbage collector can run concurrently with our Go program, it needs a way to detect potential changes in the memory while scanning. To tackle that potential issue, an algorithm of write barrier is implemented and will allow Go to track any pointer changes. The garbage finally stops the world, flushes the changes made on each write barrier to the work pool and performs the remaining marking. PS：  Write Barrier 可以追踪标记期间变化的 对象并将它们加入到work pool

[Go GC visualized](https://speakerdeck.com/deepu105/go-gc-visualized) 图解

## 整体实现

[Golang源码探索(三) GC的实现原理](https://www.cnblogs.com/zkweb/p/7880099.html)GO的GC是并行GC, 也就是GC的大部分处理和普通的go代码是同时运行的, 这让GO的GC流程比较复杂.

首先GC有四个阶段, 它们分别是:

1. Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC
2. Mark: 扫描所有根对象, 和根对象可以到达的所有对象, 标记它们不被回收
3. Mark Termination: 完成标记工作, 重新扫描部分根对象(要求STW)
4. Sweep: 按标记结果清扫span

在GC过程中会有两种后台任务(G), 一种是标记用的后台任务, 一种是清扫用的后台任务.
1. 标记用的后台任务会在需要时启动, 可以同时工作的后台任务数量大约是P的数量的25%, 也就是go所讲的让25%的cpu用在GC上的根据。也有文章说 在 GC 工作开始时，Go 会为每个处理机 P 配置一个 mark worker 线程 G 来帮助标记内存。一旦（Root）被加入待处理队列 work pool，标记周期便正式开始，mark线程 G 开始遍历 span 并标记 object。
2. 清扫用的后台任务在程序启动时会启动一个，进入清扫阶段时唤醒。

## 源码入口

`$GOROOT/src/runtime/mgc.go` go触发gc会从gcStart函数开始

[深入理解Go-垃圾回收机制](https://segmentfault.com/a/1190000020086769) 分析的非常好
1. gcStart
2. gcBgMarkStartWorkers
3. gcDrain,扫描所有的roots和对象，并表黑灰色对象，知道所有的roots和对象都被标记
4. greyobject,标灰对象其实就是找到对应bitmap，标记存活并扔进队列


Write barriers, root discovery, stack scanning, and object scanning produce pointers to grey objects. Scanning consumes pointers to grey objects, thus blackening them, and then scans them,potentially producing new pointers to grey objects. call `gcw.put()` to produce and `gcw.tryGet()` to consume.

```go
// go/1.15.2/libexec/src/runtime/mgcwork.go
// work poll 的实现
type gcWork struct {
	// wbuf1 is always the buffer we're currently pushing to and
	// popping from and wbuf2 is the buffer that will be discarded
	// next.
	wbuf1, wbuf2 *workbuf
	bytesMarked uint64
	scanWork int64
	flushedWork bool
	pauseGen uint32
	putGen uint32
	pauseStack [16]uintptr
}
```

## 其它 

GC友好的代码：避免内存分配和赋值
1. 尽量使用引用传递
2. 初始化至合适的大小
3. 复用内存

Go 的 GC 有且只会有一个参数进行调优，也就是我们所说的 GOGC，目的是为了防止大家在一大堆调优参数中摸不着头脑。 默认值是 100。这个 100 表示当内存的增加值小于等于 100% 时会强制进行一次垃圾回收。我们可以通过环境变量将这个值修改成 200，表示当内存增加 200% 时强制进行垃圾回收。或者将这个值设置为负数表示不进行垃圾回收。

小时候看动画片《一休》，提到有一次一休的师兄被惩罚去树林里数一下树有多少，结果下雨天摔倒啥的，很容易就忘了刚才数到哪了。后来一休想了个办法，拿来一捆绳子，每棵树上系一根绳子，数一下剩下多少根绳子，就知道有多少棵树了。 

[Garbage Collection In Go : Part I - Semantics](https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html)
[Garbage Collection In Go : Part II - GC Traces](https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html)
[Garbage Collection In Go : Part III - GC Pacing](https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html)