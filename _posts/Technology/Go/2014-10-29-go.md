---

layout: post
title: Go基础
category: 技术
tags: Go
keywords: Go

---

## 简介

* TOC
{:toc}

大神的一份学习笔记 https://github.com/hoanhan101/ultimate-go 

[Golang 官网的FAQ](https://golang.org/doc/faq) 也经常会有一些“灵魂追问”的解答。

## Language Mechanics

### Syntax

Go语言设计有很多硬性规则，这让代码格式化、代码分析、编译、单元测试比较方便。

与常见编程语言的不同之处：

1. 变量类型 在变量右侧，https://blog.go-zh.org/gos-declaration-syntax 官方有给出解释，原因简单来说就是和C相比，在当参数是指针的复杂情况下，这种声明格式会相对好理解一点
1. Go的赋值方式很多，据说在Go后续的优化中会只支持一种赋值方式。PS：“达成一个目的只允许有一种方法”，就是这么直接。
2. 赋值可以进行自动类型推断，在一个赋值语句中可以对多个变量进行同时赋值
4. Go语言不允许隐式类型转换，别名和原有类型也不能进行隐式类型转换
6. 支持指针类型，但不支持指针运算，也不能获取常量的指针，仅能修改指针指向的值。
8. Go语言没有前置++,--
9. 支持按位清零运算符`&^`
10. Go语言循环仅支持关键字 for
11. 不需要用break 来明确退出一个case，case 可以多项
12. 可以不设定switch 之后的条件表达式， 在此种情况下， 整个switch 结构与多个if else 的逻辑作用等同。 
13. For break and continue, the additional label lets you specify which loop you would like to refer to. For example, you may want to break/continue the outer loop instead of the one that you nested in.
    ```go
    RowLoop:
        for y, row := range rows {
            for x, data := range row {
                if data == endOfRow {
                    break RowLoop
                }
                row[x] = data + bias(x, y)
            }
        }
    ```
14. go 关键字对应到 java 就像一个无限容量的 Executor，可以随时随地 submit Runable

## Data Structures

||go|java|
|---|---|---|
|list|slice|ArrayList|
|map|map|HashMap|
|线程安全map|sync.Map|ConcurrentHashMap|
|对象池|对带缓冲的channel进行封装|commons-pool中的ObjectPool|


golang为什么将method写在类外? go表达的就是函数就是函数，数据就是数据。与数据绑定的函数提供t.foo()这种写法。但也仅此而已了。不要用面向对象语言的思想去学go，用c的思路去学go，golang之所以叫struct不叫class，go没有类，只是模拟它



### 数组

[Deep Dive into Pointers, Arrays & Slice](https://medium.com/@dwdraju/deep-dive-into-pointers-arrays-slice-309a843c63ad)Go’s arrays are values rather than memory address.

```go
var myarr = [...]int{1,2,3}
fmt.Println(myarr)
fmt.Println(&myarr)
//output
[1 2 3] // 打印的时候直接把值给打印出来了
&[1 2 3]
```

在 Go 中，与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和函数传参操作都会复制整个数组数据。值类型还体现在

1. 相同维数且包含相同个数元素的数组才可以比较
2. 每个元素都相同的才相等

### slice

![](/public/upload/go/slice.png)

切片与数组的关系非常密切，切片引入了一个**抽象层**，提供了对数组中部分片段的引用，我们可以在运行区间可以修改它的长度，如果底层的数组长度不足就会触发扩容机制，切片中的数组就会发生变化，不过在上层看来切片是没有变化的，上层只需要与切片打交道不需要关心底层的数组变化。

```go
// $GOROOT/src/runtime/slice.go
type slice struct {
	array unsafe.Pointer        // 指向底层数组的指针
	len   int                   // 可以用下标访问的元素个数
	cap   int                   // 底层数组长度
}
func makeslice(et *_type, len, cap int) unsafe.Pointer {...}
func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer {...}
// growslice handles slice growth during append.It is passed the slice element type, the old slice, and the desired new minimum capacity,and it returns a new slice with at least that capacity, with the old data copied into it.
func growslice(et *_type, old slice, cap int) slice {...}
func slicecopy(to, fm slice, width uintptr) int {...}
func slicestringcopy(to []byte, fm string) int {...}
```
扩容的本质过程：扩容实际上就是重新分配一块更大的内存，将原先的Slice数据拷贝到新的Slice中，然后返回新Slice，扩容后再将数据追加进去。

与java ArrayList相比，slice 本身不提供类似 Add/Set/Remove方法。只有一个builtin 的append和切片功能，因为不提供crud方法，**slice 更多作为一个“受体”**，与数组更近，与“ArrayList”更远。

```go
// $GOROOT/src/builtin/builtin.go
// The append built-in function appends elements to the end of a slice. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it does not, a new underlying array will be allocated. Append returns the updated slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself:
//	slice = append(slice, elem1, elem2)
//	slice = append(slice, anotherSlice...)
func append(slice []Type, elems ...Type) []Type
```

对于所有的 range 循环，Go 语言都会在编译期将原切片或者数组（下例中的arr）赋值给一个新的变量 ha，在赋值的过程中就发生了拷贝，所以我们遍历的切片已经不是原始的切片变量（arr）了。

```go
func main() {
	arr := []int{1, 2, 3}
	for _, v := range arr {
		arr = append(arr, v)
	}
	fmt.Println(arr)
}
$ go run main.go
1 2 3 1 2 3
```

之前将java 中的代码优化思路用到了 go 上，以为`ss := make([]string, 5)` 就是一个预分配了长度为5 的list，go 中这行代码 不仅分配了长度为5的空间，元素也赋值好了。

```go
ss := make([]string, 5) 
ss = append(ss, "abc")
fmt.Println(len(strs))  // 输出6
```



### map

与常见编程语言的不同之处：

1. 在访问的key不存在时，仍会返回零值，不能通过返回nil 来判断元素是否存在。
2. Map的value 可以是一个方法，与Go的Dock type 方式一起， 可以方便的实现单一方法对象的工厂模式。

    ```go
    m := map[int]func(op int) int{}
	m[1] = func(op int) int { return op }
	m[2] = func(op int) int { return op * op }
	m[3] = func(op int) int { return op * op * op }
	t.Log(m[1](2), m[2](2), m[3](2))
    ```

3. Go的内置集合中没有Set实现， 可以`map[type]bool`

对于slice 来说， index, value 可以视为一个kv

```go
for k,v := range map{}
for i,v := range slice{}
```

### string

Go**原生支持**字符串（比如底层结构有专门字段存储字符串长度），string 类型的数据是不可变的，string 是值类型， 其默认初始化值为空字符串，不是nil

```go
// $GOROOT/src/reflect/value.go
// StringHeader是一个string的运行时表示
type StringHeader struct {
    Data uintptr    // 真实的字符串值数据就存储在一个被 Data 指向的底层数组中
    Len  int
}
```

了解了 string 类型的实现原理后，我们还可以得到这样一个结论，那就是我们直接将 string 类型通过函数 / 方法参数传入也不会带来太多的开销。因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。其传递的开销也是恒定的，不会随着字符串大小的变化而变化。PS: go 中都是值传递，是不是可以认为，如果不想因为值传递 copy 太多数据，可以值传递的数据结构 不能直接 包含 指向的数据

与常见编程语言的不同之处：

1. string 是数据类型， 不是引用或指针类型
2. string 是只读的byte slice，len函数 返回的是byte 数
3. string的 byte 数组可以存放任何数据

## Decoupling/解耦

### 函数

与常见编程语言的不同之处：

1. 可以返回多个值
2. 所有的参数传递都是值传递：slice,map,channel 会有传引用的错觉
3. 函数是一等公民 ==> 对象之间的复杂关系可以由函数来部分替代
    2. 函数可以作为变量的值
    3. 函数可以作为参数和返回值

比如通过函数式编程来实现装饰模式，让一个函数具有计时能力
```go
func timeSpent(inner func(op int) int) func(op int) int {
	return func(n int) int {
		start := time.Now()
		ret := inner(n)
		fmt.Println("time spent:", time.Since(start).Seconds())
		return ret
	}
}
```

嫌弃这个方法定义太长的话可以
```go
type IntConv func(op int) int
func timeSpent(inner IntConv) IntConv {
	return func(n int) int {
		start := time.Now()
		ret := inner(n)
		fmt.Println("time spent:", time.Since(start).Seconds())
		return ret
	}
}
```



## Error Handling

与常见编程语言的不同之处：

1. 没有异常机制。之前的语言 函数只支持一个返回值， 业务逻辑返回与错误返回会争用这一个“名额”，后来支持抛异常，算是解决了“争用”，但大量的try catch 引入了新的问题（至少Go作者不喜欢）。Go 支持了多返回值，从另一种视角解决了业务逻辑返回与错误返回“争用”问题。
2. error 类型实现了error 接口
3. 可以通过errors.New 来快速创建错误实例。 

可以在代码中预创建一些错误`var LessThanTwoError = errors.New("n should be not less than 2")`，以便比对和复用。 

## Go Test 和 Benchmark

我们测试一个函数的功能，就必须要运行该函数，而这往往是由main函数开始触发的。在大型项目中，测试一个函数的功能，总是劳驾main函数很不方便，于是我们可以使用`go test`功能。

假设存在`a.go`文件（文件中包含Add方法），我们只要在相同目录下创建`a_test.go`文件，在该目录下运行`go test`即可。（这将运行该目录下所有"_test"后缀文件中的带有“Test”前缀的方法）

```go
package main
import (
    "fmt"
    "testing"
)
// 功能测试
func TestAdd(t *testing.T) {
    t.Log("hello","world")
    re := Add(3,4)
    if re != 7{
        t.Error("error")
    } 
    assert.Equal(re,7)
}
// 性能测试
func BenchmarkAdd(b *testing.B) {
    b.ResetTimer()
    ...// 测试代码
    b.StopTimer()
}
```


![](/public/upload/go/go_practice.jpg)

[你想知道的 Go 泛型都在这里](https://mp.weixin.qq.com/s/ZmKnD53xKyQWwuj64rL_7A)







